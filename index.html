<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multi Timer with Countdown and Excel Export</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 0px;
      margin: 0px;
      text-align: center;
    }

    h1 {
      margin-bottom: 10px;
    }

    #filename-input {
      margin-bottom: 5px;
      padding: 5px;
      font-size: 1em;
    }

    #countdown-container {
      margin-bottom: 0px;
    }

    #grid-container {
      display: grid;
      grid-template-columns: repeat(2, minmax(100px, 1fr));
      grid-template-rows: auto auto;
      gap: 120px;
      justify-items: center;
      align-items: center;
      position: relative;
      max-width: 600px;
      margin: 0 auto 0px auto;
    }

    .timer-block {
      text-align: center;
      padding: 10px;
      margin: 10px;
      width: auto;         
      max-width: 100%;     
      box-sizing: border-box;
    }

    .timer-label {
      font-weight: bold;
      font-size: 1.2em;
      display: inline-block;
      min-width: 180px;
      white-space: nowrap;
    }

    .time-display {
      font-size: 1.5em;
      display: block;
      margin: 10px 0;
    }

    button {
      margin: 0 3px;
      padding: 5px 10px;
    }

    .disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    #center-image {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 150px;
      height: 150px;
      transform: translate(-50%, -50%);
      z-index: 1;
      opacity: 1;
    }

    #start-btn {
      background-color: #0096FF;
      color: white;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      padding: 6px 14px;
      margin-left: 10px;
    }

    #save-btn {
      background-color: #4CAF50;
      color: white;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      padding: 6px 14px;
      margin-left: 10px;
    }

    #export-rows-btn {
      background-color: #FFA500;
      color: white;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      padding: 6px 14px;
      margin-left: 10px;
    }

    #pause-resume-btn {
      background-color: #808080;
      color: white;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      padding: 6px 14px;
      margin-left: 10px;
    }

    #reset-btn {
      background-color: #FF0000;
      color: white;
      font-weight: bold;
      border: none;
      border-radius: 5px;
      padding: 6px 14px;
      margin-left: 10px;
    }

  </style>
</head>
<body>

<h1>OLD Timer - Object Scoring </h1>
<h3 style="margin-top: 5px; font-weight: normal; color: #555;">
  Copyright &copy; 2025 Olivia Drayson
</h3>

<div id="top-input-row" style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 10px;">
  <input type="text" id="filename-input" placeholder="Project Name (optional)" style="padding: 5px; width: 180px;">

  <select id="experiment-type" style="padding: 5px;">
    <option value="">Select Experiment</option>
    <option value="NOR_Train">NOR Novel Object Recognition (Training)</option>
    <option value="NOR_Test">NOR Novel Object Recognition (Testing)</option>
    <option value="OLM_Train">OLM Object Location Memory (Training)</option>
    <option value="OLM_Test">OLM Object Location Memory (Testing)</option>
    <option value="OUL_Test">OUL Object in Updated Location (Testing)</option>
    <option value="OiP_Train">OiP Objects in Place (Training)</option>
    <option value="OiP_Test">OiP Objects in Place (Testing)</option>
    <option value="TO_Train_1">TO Temporal Order (Training Phase 1)</option>
    <option value="TO_Train_2">TO Temporal Order (Training Phase 2)</option>
    <option value="TO_Test">TO Temporal Order (Testing)</option>
  </select>
</div>

<div id="round-row" style="display: flex; align-items: center; justify-content: center; gap: 10px; margin-bottom: 20px;">

  <label for="round-input">Round:</label>
  <input type="text" id="round-input" placeholder="e.g. 1" style="width: 50px; padding: 5px;">

  <label for="arena-input">Arena:</label>
  <input type="text" id="arena-input" placeholder="e.g. 1" style="width: 50px; padding: 5px;">

</div>


<div id="countdown-container">
  <label for="countdown-input">Countdown (mm:ss): </label>
  <input type="text" id="countdown-input" value="05:00" style="width: 70px; padding: 5px;">
  <button id="start-btn" onclick="startCountdown()">Start Countdown</button>
  <button id="pause-resume-btn" onclick="pauseOrResumeCountdown()" disabled>Pause</button>
  <span id="countdown-display" style="margin-left: 20px; font-size: 1.2em;"></span>
  <button id="reset-btn" onclick="resetAllTimers()" style="margin-left: 10px; padding: 6px 14px;">Reset All</button>
</div>

<div id="grid-container">
  // <img src=![MouseImage](mouseimage.jpg) id="center-image" alt="Center Image">
  <img src="https://OliviaDrayson.github.io/OldTimer/mouseimage.jpg" id="center-image" alt="Center Image">
</div>

<div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: center;">
  <button id="save-btn" onclick="exportToExcel()">Save to Excel</button>
  <button id="export-rows-btn" onclick="exportRowData()">Export Row Data</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script>
  const numTimers = 4;
  const timers = [];
  const pressCounts = Array(numTimers).fill(0);
  const pressTimestamps = Array(numTimers).fill().map(() => []);
  const pressDurations = Array(numTimers).fill().map(() => []);
  const intervals = [];
  const timerDisplays = [];
  const keyMap = { 'a': 0, 'k': 1, 'z': 2, 'm': 3 };
  const keyHints = ['a', 'k', 'z', 'm'];
  const timerNames = ['Top Left', 'Top Right', 'Bottom Left', 'Bottom Right'];
  const activeKeys = {};
  let countdownInterval = null;
  let countdownEndTime = null;
  let countdownRunning = false;
  let countdownStartTime = null;
	
  function formatTime(ms) {
    const minutes = Math.floor(ms / 60000).toString().padStart(2, '0');
    const seconds = Math.floor((ms % 60000) / 1000).toString().padStart(2, '0');
    const millis = (ms % 1000).toString().padStart(3, '0');
    return `${minutes}:${seconds}:${millis}`;
  }

  function createTimerElement(index) {
    const block = document.createElement('div');
    block.className = 'timer-block';
    block.innerHTML = `
      <div class="timer-label">${timerNames[index]} (key '${keyHints[index]}'):</div>
      <input type="text" id="description-${index}" placeholder="Description (optional)" style="margin-top:5px; margin-bottom:10px; width:90%;">
      <span class="time-display" id="display-${index}">00:00:000</span>
      <button onclick="toggleTimer(${index})" id="startstop-${index}">Start</button>
      <button onclick="resetTimer(${index})" id="reset-${index}">Reset</button>
    `;
    document.getElementById('grid-container').appendChild(block);
  }

  function updateTimer(index) {
    const elapsed = Date.now() - timers[index].start + timers[index].accumulated;
    timerDisplays[index].textContent = formatTime(elapsed);
  }

  function startTimer(index) {
    if (!countdownRunning || timers[index].running) return;
    timers[index].start = Date.now();
    intervals[index] = setInterval(() => updateTimer(index), 10);
    timers[index].running = true;
    document.getElementById(`startstop-${index}`).textContent = 'Stop';
  }

function stopTimer(index) {
  if (!timers[index].running || timers[index].start == null) return;

  const now = Date.now();
  clearInterval(intervals[index]);

  const duration = now - timers[index].start;

  if (!isNaN(duration) && duration >= 0 && countdownStartTime !== null) {
    timers[index].accumulated += duration;

    const relativeTimestamp = now - countdownStartTime;
    pressTimestamps[index].push(relativeTimestamp);
    pressDurations[index].push(duration);
  }

  timers[index].running = false;
  timers[index].start = null;

  document.getElementById(`startstop-${index}`).textContent = 'Start';
}


  function toggleTimer(index) {
    if (!countdownRunning) return;

    pressCounts[index]++;  // Increment counter

    if (timers[index].running) {
      stopTimer(index);
    } else {
      startTimer(index);
    }

  }

  function resetTimer(index) {
    stopTimer(index);
    timers[index].accumulated = 0;
    timerDisplays[index].textContent = '00:00:000';
 }

  function disableAllTimers() {
    for (let i = 0; i < numTimers; i++) {
      stopTimer(i);
      document.getElementById(`startstop-${i}`).classList.add('disabled');
      document.getElementById(`reset-${i}`).classList.add('disabled');
    }
  }

  function enableAllTimers() {
    for (let i = 0; i < numTimers; i++) {
      document.getElementById(`startstop-${i}`).classList.remove('disabled');
      document.getElementById(`reset-${i}`).classList.remove('disabled');
    }
  }

  function parseCountdownInput() {
    const input = document.getElementById('countdown-input').value;
    const parts = input.split(':');
    if (parts.length !== 2) return 0;
    const minutes = parseInt(parts[0]) || 0;
    const seconds = parseInt(parts[1]) || 0;
    return (minutes * 60 + seconds) * 1000;
  }

function updateCountdownDisplay(timeLeft) {
  const minutes = Math.floor(timeLeft / 60000);
  const seconds = Math.floor((timeLeft % 60000) / 1000);
  document.getElementById('countdown-display').textContent = 
    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

function startCountdown() {
  const duration = parseCountdownInput();
  if (duration <= 0) return alert('Enter a valid countdown.');

  countdownStartTime = Date.now();
  countdownEndTime = countdownStartTime + duration;
  countdownRunning = true;

  document.getElementById('pause-resume-btn').disabled = false;

  updateCountdownDisplay(duration);
  enableAllTimers();

  countdownInterval = setInterval(() => {
    const timeLeft = countdownEndTime - Date.now();
    if (timeLeft <= 0) {
      clearInterval(countdownInterval);
      updateCountdownDisplay(0);
      countdownRunning = false;
      disableAllTimers();

      document.getElementById('start-btn').disabled = false;
      document.getElementById('start-btn').classList.remove('disabled');
    } else {
      updateCountdownDisplay(timeLeft);
    }
  }, 200);
}

function recordPress() {
  if (!countdownStartTime) return;
  
  if (!pressStartTime) {
    pressStartTime = Date.now(); // Start press timer
  } else {
    // Calculate duration in milliseconds
    const duration = Date.now() - pressStartTime;
    const timestamp = Date.now() - countdownStartTime;
    
    // Generate row data with correct timestamps
    const row = {
      trial: trialCounter,
      timer: "Top Right", // Or get from UI
      timestamp: isNaN(timestamp) ? null : timestamp,
      duration: isNaN(duration) ? null : duration
    };
    
    // Add to results and reset
    results.push(row);
    trialCounter++;
    pressStartTime = null; // Reset press start time
    updateDisplay();
  }
}

  function pauseOrResumeCountdown() {
    const btn = document.getElementById('pause-resume-btn');
    if (countdownRunning) {
      clearInterval(countdownInterval);
      countdownRunning = false;
      countdownEndTime -= Date.now(); // store remaining time as offset
      btn.textContent = 'Resume';
    } else {
      countdownEndTime = Date.now() + countdownEndTime; // apply offset
      countdownRunning = true;
      btn.textContent = 'Pause';

      countdownInterval = setInterval(() => {
        const timeLeft = countdownEndTime - Date.now();
        if (timeLeft <= 0) {
          clearInterval(countdownInterval);
          updateCountdownDisplay(0);
          countdownRunning = false;
          disableAllTimers();
          btn.disabled = true;
        } else {
          updateCountdownDisplay(timeLeft);
        }
      }, 200);
    }
  }

function resetCountdown() {
  if (countdownInterval) {
    clearInterval(countdownInterval);
  }
  countdownRunning = false;
  countdownEndTime = null;
  document.getElementById('countdown-display').textContent = '';

  // Re-enable Start Countdown button
  const startBtn = document.getElementById('start-btn');
  startBtn.disabled = false;
  startBtn.classList.remove('disabled');

  // Also reset Pause button
  const pauseBtn = document.getElementById('pause-resume-btn');
  pauseBtn.disabled = true;
  pauseBtn.textContent = 'Pause';

  disableAllTimers();
}


  function resetAllTimers() {
    for (let i = 0; i < numTimers; i++) {
      resetTimer(i);
      timers[i].timestamps = [];
    }
    resetCountdown();
    countdownStartTime = null;
  }

function exportToExcel() {
  const projectName = document.getElementById('filename-input').value.trim() || 'Project';
  const experimentType = document.getElementById('experiment-type').value || 'UnknownExp';
  const roundValue = document.getElementById('round-input').value.trim() || '0';
  const arenaValue = document.getElementById('arena-input').value.trim() || '0';

  const roundLabel = `R${roundValue}`;
  const arenaLabel = `A${arenaValue}`;
  const filename = `${projectName}_${experimentType}_${roundLabel}_${arenaLabel}.xlsx`;

  const wsData = [['Timer', 'Description', 'Total Time (mm:ss:ms)', 'Total Time (s.sss)', 'Press Count', 'Timestamps']];

  for (let i = 0; i < numTimers; i++) {
    const desc = document.getElementById(`description-${i}`)?.value.trim() || '';
    const accumulatedMs = timers[i].accumulated || 0;
    const totalTimeFormatted = formatTime(accumulatedMs);
    const totalTimeSeconds = (accumulatedMs / 1000).toFixed(3);
    const pressCount = pressCounts[i] || 0;

    const timestamps = pressTimestamps[i] || [];
    const readableTimestamps = timestamps.map(ms => formatTime(ms)).join(', ');

    wsData.push([
      timerNames[i],
      desc,
      totalTimeFormatted,
      totalTimeSeconds,
      pressCount,
      readableTimestamps
    ]);
  }

  // Add metadata rows at the top
  wsData.unshift([]);
  wsData.unshift(['Arena', arenaValue]);
  wsData.unshift(['Round', roundValue]);
  wsData.unshift(['Experiment Type', experimentType]);

  const ws = XLSX.utils.aoa_to_sheet(wsData);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Timers');
  XLSX.writeFile(wb, filename);
}

function exportRowData() {
  const projectName = document.getElementById('filename-input').value.trim() || 'Project';
  const experimentType = document.getElementById('experiment-type').value || 'UnknownExp';
  const roundValue = document.getElementById('round-input').value.trim() || '0';
  const arenaValue = document.getElementById('arena-input').value.trim() || '0';

  const roundLabel = `R${roundValue}`;
  const arenaLabel = `A${arenaValue}`;
  const filename = `${projectName}_${experimentType}_${roundLabel}_${arenaLabel}_rowdata.csv`;

  const csvData = [
    ['Trial', 'Timer', 'Description', 'Timestamp (ms)', 'Duration (s)']
  ];

  let trial = 1;

  for (let i = 0; i < numTimers; i++) {
    const timerName = timerNames[i];
    const description = document.getElementById(`description-${i}`)?.value.trim() || '';
    const timestamps = pressTimestamps[i];
    const durations = pressDurations[i];

    for (let j = 0; j < timestamps.length; j++) {
      const msSinceStart = timestamps[j];
      const durationInSeconds = durations[j] ? (durations[j] / 1000).toFixed(3) : '';
      csvData.push([trial++, timerName, description, msSinceStart, durationInSeconds]);
    }
  }

  // Convert 2D array to CSV string
  const csv = csvData.map(row => 
    row.map(cell => `"${cell}"`).join(',')
  ).join('\n');

  // Create and trigger download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}


  // Init
  for (let i = 0; i < numTimers; i++) {
    createTimerElement(i);
    timers.push({ running: false, start: 0, accumulated: 0 });
    timerDisplays.push(document.getElementById(`display-${i}`));
  }

  disableAllTimers();

  // Keyboard control

  document.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();
    if (keyMap.hasOwnProperty(key) && countdownRunning && !activeKeys[key]) {
      activeKeys[key] = true;
      toggleTimer(keyMap[key]);  // <-- This now logs timestamp and press count
    }
  });

  document.addEventListener('keyup', (e) => {
    const key = e.key.toLowerCase();
    if (keyMap.hasOwnProperty(key)) {
      activeKeys[key] = false;
      stopTimer(keyMap[key]);
    }
  });




</script>

</body>
</html>
